[{"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": 1, "children": [{"kind": "t3", "data": {"is_crosspostable": false, "subreddit_id": "t5_2tex6", "approved_at_utc": null, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "thumbnail_width": 140, "subreddit": "ProgrammerHumor", "selftext_html": null, "selftext": "", "likes": null, "suggested_sort": null, "mod_note": null, "user_reports": [], "secure_media": null, "is_reddit_media_domain": false, "saved": false, "id": "5m6bdv", "banned_at_utc": null, "mod_reason_title": null, "view_count": null, "archived": true, "clicked": false, "no_follow": false, "author": "lifeprobe", "num_crossposts": 0, "link_flair_text": null, "can_mod_post": false, "send_replies": true, "pinned": false, "score": 56, "approved_by": null, "over_18": false, "domain": "stackoverflow.com", "hidden": false, "preview": {"images": [{"source": {"url": "https://i.redditmedia.com/yzSfTlKTSYGpEXeFgyDvHlfoLGOFQJqPuH_Y38RBz2U.jpg?s=5771b03e94f56162bcafaf1079f2a1e7", "width": 316, "height": 316}, "resolutions": [{"url": "https://i.redditmedia.com/yzSfTlKTSYGpEXeFgyDvHlfoLGOFQJqPuH_Y38RBz2U.jpg?fit=crop&amp;crop=faces%2Centropy&amp;arh=2&amp;w=108&amp;s=9189a7b196263db4825e3ab0c948e796", "width": 108, "height": 108}, {"url": "https://i.redditmedia.com/yzSfTlKTSYGpEXeFgyDvHlfoLGOFQJqPuH_Y38RBz2U.jpg?fit=crop&amp;crop=faces%2Centropy&amp;arh=2&amp;w=216&amp;s=c442ba677155996a0a49f51a400124b1", "width": 216, "height": 216}], "variants": {}, "id": "nfayPavSUB5ngYv6-19UHNBThsXfcLIDQl4HkEe3Cv0"}], "enabled": false}, "num_comments": 8, "thumbnail": "https://b.thumbs.redditmedia.com/MB8RL-1BLubzAAfSS-WxFI6UNgfsgSIYnn0slz7zz5s.jpg", "hide_score": false, "edited": false, "link_flair_css_class": null, "author_flair_css_class": null, "contest_mode": false, "gilded": 0, "locked": false, "downs": 0, "brand_safe": true, "subreddit_subscribers": 482122, "secure_media_embed": {}, "media_embed": {}, "post_hint": "link", "stickied": false, "can_gild": false, "thumbnail_height": 140, "parent_whitelist_status": "all_ads", "name": "t3_5m6bdv", "spoiler": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/", "subreddit_type": "public", "whitelist_status": "all_ads", "report_reasons": null, "created": 1483650957.0, "url": "http://stackoverflow.com/questions/1659559/what-makes-python-a-good-scripting-language", "author_flair_text": null, "quarantine": false, "title": "I don't like it", "created_utc": 1483622157.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "distinguished": null, "media": null, "upvote_ratio": 0.94, "mod_reports": [], "is_self": false, "visited": false, "num_reports": null, "is_video": false, "ups": 56}}], "before": null}}, {"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": null, "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 17, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": false, "replies": "", "user_reports": [], "saved": false, "id": "dc1kdaq", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "cjwelborn", "can_mod_post": false, "send_replies": true, "parent_id": "t3_5m6bdv", "score": 17, "approved_by": null, "downs": 0, "body": "Should've linked to the [actual comment](http://stackoverflow.com/questions/1659559/what-makes-python-a-good-scripting-language#comment1531763_1659564).", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Should&amp;#39;ve linked to the &lt;a href=\"http://stackoverflow.com/questions/1659559/what-makes-python-a-good-scripting-language#comment1531763_1659564\"&gt;actual comment&lt;/a&gt;.&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc1kdaq", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc1kdaq/", "num_reports": null, "stickied": false, "created": 1483672736.0, "author_flair_text": null, "created_utc": 1483643936.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 0, "mod_reports": [], "mod_note": null, "distinguished": null}}, {"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 9, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": false, "replies": {"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": null, "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": -3, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": true, "replies": {"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": null, "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 6, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": false, "replies": {"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": null, "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 5, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": false, "replies": {"kind": "Listing", "data": {"after": null, "whitelist_status": "all_ads", "modhash": "", "dist": null, "children": [{"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 1, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": true, "replies": "", "user_reports": [], "saved": false, "id": "dc3q7hr", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "noratat", "can_mod_post": false, "send_replies": true, "parent_id": "t1_dc2uazf", "score": 1, "approved_by": null, "downs": 0, "body": "Please note I'm not trying to say people shouldn't use Python - the part about having a very large and active ecosystem that tends to be well documented is incredibly important, and a very good reason to use Python for that reason alone!\n\nAnd I understand that most of these quirks have technical rationales that make (some) sense in the underlying context, but the same could be said of C++ and it's many syntactical quirks and oddities.\n\nIt doesn't change the fact that, as an actual developer working with Python, the language feels very strange and quirky (and therefore unintuitive) when coming from other common scripting languages, especially when dealing with functional programming idioms.\n\nGenerators in particular bug the shit out of me coming from languages like Groovy and Ruby, because they feel way too much like stateful gotos - sure, you can implement lazy collections with them, but I'm not sure that needed to be exposed as a top-level syntactical feature given the risks, and I've found them to be much harder to reason about despite the deceptively simple syntax.\n\n&gt;Same principle as implementing .\\_\\_add__() to add language-support for addition, and you wouldn't want to have a a method .add() for every numeric type. \n\nI'm not actually sure what you're trying to say here. Whether implemented as a hidden interface / \"protocol\" or as an actual method, you'll still technically have an implementation of add for every numeric type either way.", "edited": 1483755932.0, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Please note I&amp;#39;m not trying to say people shouldn&amp;#39;t use Python - the part about having a very large and active ecosystem that tends to be well documented is incredibly important, and a very good reason to use Python for that reason alone!&lt;/p&gt;\n\n&lt;p&gt;And I understand that most of these quirks have technical rationales that make (some) sense in the underlying context, but the same could be said of C++ and it&amp;#39;s many syntactical quirks and oddities.&lt;/p&gt;\n\n&lt;p&gt;It doesn&amp;#39;t change the fact that, as an actual developer working with Python, the language feels very strange and quirky (and therefore unintuitive) when coming from other common scripting languages, especially when dealing with functional programming idioms.&lt;/p&gt;\n\n&lt;p&gt;Generators in particular bug the shit out of me coming from languages like Groovy and Ruby, because they feel way too much like stateful gotos - sure, you can implement lazy collections with them, but I&amp;#39;m not sure that needed to be exposed as a top-level syntactical feature given the risks, and I&amp;#39;ve found them to be much harder to reason about despite the deceptively simple syntax.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;Same principle as implementing .__add__() to add language-support for addition, and you wouldn&amp;#39;t want to have a a method .add() for every numeric type. &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;I&amp;#39;m not actually sure what you&amp;#39;re trying to say here. Whether implemented as a hidden interface / &amp;quot;protocol&amp;quot; or as an actual method, you&amp;#39;ll still technically have an implementation of add for every numeric type either way.&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc3q7hr", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc3q7hr/", "num_reports": null, "stickied": false, "created": 1483784356.0, "author_flair_text": null, "created_utc": 1483755556.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 4, "mod_reports": [], "mod_note": null, "distinguished": null}}, {"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 1, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": true, "replies": "", "user_reports": [], "saved": false, "id": "dc35l6e", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "boramalper", "can_mod_post": false, "send_replies": true, "parent_id": "t1_dc2uazf", "score": 1, "approved_by": null, "downs": 0, "body": "Thanks for actually spending time for responding to an ignorant commentary. =)", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;Thanks for actually spending time for responding to an ignorant commentary. =)&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc35l6e", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc35l6e/", "num_reports": null, "stickied": false, "created": 1483758872.0, "author_flair_text": null, "created_utc": 1483730072.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 4, "mod_reports": [], "mod_note": null, "distinguished": null}}], "before": null}}, "user_reports": [], "saved": false, "id": "dc2uazf", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "FelkCraft", "can_mod_post": false, "send_replies": true, "parent_id": "t1_dc28z4e", "score": 5, "approved_by": null, "downs": 0, "body": "The lambda limitation exists, yes. That doesn't make anything you could do with them more unpleasant though, as python has first-class functions. If it's a short lambda, expressions are sufficient. If it's a bit longer, might as well give it a name, for example:\n\n    def by_mtime(filename):\n        fullpath = os.path.join(savepath, filename)\n        return os.path.getmtime(fullpath)\n    newest_save = max(files, key=by_mtime)\n\nAlso, can you call Java 8 lambdas \"real\"? They are just syntactic sugar for implementing a functional interface, as Java has no first-class functions afterall.\n\n---\n\nYes, Python got the f-strings late. Though being forced to explicitly tell the language what data to interpolate isn't as horrific as you make it look.  \nFor example: `print(\"{name} scored {score:-12,d} points.\".format(**player))` vs. the new `print(f\"{player['name']} scored {player['score']:-12,d} points.\")`.\n\nUsage of the printf-like formatting (`print(\"%s scored %12d points.\" % (player[\"name\"], player[\"score\"]))`) is discouraged for a long time already. Only place in the stdlib I know of where it's necessary to use is the logging library, to maintain backwards compatibility. There aren't 3-4 different builtin ways to do string interpolation, there is 1 new and 1 \"old\" way, and they are fairly similar too.\n\n---\n\nPython uses C-style imperative APIs where appropriate, and it uses an OO-approach where appropriate. Programming paradigms are not exclusive.\n\n`str.endswith()` can operate on strings, while `len()` can operate on _any_ sequence. Python has no interfaces, therefore there is no common type of which `len()` operates on. Instead, Python uses protocols to add builtin behaviors to objects. And implementing protocols happens via double-underscored methods, `.__len__()` in this example. Same principle as implementing `.__add__()` to add language-support for addition, and you wouldn't want to have a a method `.add()` for every numeric type. The reason for having `len(x)` and not `x.len()` is to avoid name clashes (an empty class in python actually has no non-underscored methods, unlike inherited/builtin methods in other languages), and to be able to fulfill protocols in more than some ways. For example something can be turned into an iterator using `iter()` if it either defines `.__iter__()`, or is a sequence container by defining `.__getitem__()`.\n\nEven if it would have actual interfaces, it's doubtful if `len()` would be a method then. Other languages do this too in some cases, for example C++ has `std::begin()` and `std::end()`, which allows for a more generic approach than the `.begin()` and `.end()` member functions.\n\n`str.join()` is the way it is, because it operates on a string and on any iterable (be it lists, tuples, generators etc.). So you can put the functionality into the string (reads as \"join that sequence with this string\"), or into every iterable (aka as another protocol, reads as \"join this sequence with that string\"). It was decided to not do the latter just for the sake of consistency to other languages. You can also use methods as functions if you want: `str.join(\",\", [\"a\", \"b\", \"c\"])`\n\n---\n\nI don't understand what you mean by \"generators versus iterators versus comprehensions\". A generator is simply a subroutine that lazily returns singular values as a sequence using `yield` instead of `return`. That's consistent with other languages (e.g. IEnumerable in C#, or any language supporting coroutines)\n\ncomprehensions are just a shorthand for a combination of two of the most common functional operations: `map()` and `filter()`. `(expr for item in sequence if condition)` is equivalent to `map(expr, filter(condition, sequence))`. Not sure what's unintuitive. SQL does the same: `SELECT expr FROM table WHERE condition`. And it's consistent for list-, dict-, set- and generator-expressions.\n\nWhat exactly is \"iterator syntax\"? If you conform to the iterator protocol, you can be an iterator. sequences can be iterated. comprehensions can be iterated. lists can be iterated. Just like `len()`, it's a builtin feature, whose protocol you can implement with `__iter__` and `__next__`, as I mentioned before.\n\n---\n\nI spent way too much time writing this, but hey, I learned stuff while researching. ", "edited": 1483717838.0, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The lambda limitation exists, yes. That doesn&amp;#39;t make anything you could do with them more unpleasant though, as python has first-class functions. If it&amp;#39;s a short lambda, expressions are sufficient. If it&amp;#39;s a bit longer, might as well give it a name, for example:&lt;/p&gt;\n\n&lt;pre&gt;&lt;code&gt;def by_mtime(filename):\n    fullpath = os.path.join(savepath, filename)\n    return os.path.getmtime(fullpath)\nnewest_save = max(files, key=by_mtime)\n&lt;/code&gt;&lt;/pre&gt;\n\n&lt;p&gt;Also, can you call Java 8 lambdas &amp;quot;real&amp;quot;? They are just syntactic sugar for implementing a functional interface, as Java has no first-class functions afterall.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;Yes, Python got the f-strings late. Though being forced to explicitly tell the language what data to interpolate isn&amp;#39;t as horrific as you make it look.&lt;br/&gt;\nFor example: &lt;code&gt;print(&amp;quot;{name} scored {score:-12,d} points.&amp;quot;.format(**player))&lt;/code&gt; vs. the new &lt;code&gt;print(f&amp;quot;{player[&amp;#39;name&amp;#39;]} scored {player[&amp;#39;score&amp;#39;]:-12,d} points.&amp;quot;)&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Usage of the printf-like formatting (&lt;code&gt;print(&amp;quot;%s scored %12d points.&amp;quot; % (player[&amp;quot;name&amp;quot;], player[&amp;quot;score&amp;quot;]))&lt;/code&gt;) is discouraged for a long time already. Only place in the stdlib I know of where it&amp;#39;s necessary to use is the logging library, to maintain backwards compatibility. There aren&amp;#39;t 3-4 different builtin ways to do string interpolation, there is 1 new and 1 &amp;quot;old&amp;quot; way, and they are fairly similar too.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;Python uses C-style imperative APIs where appropriate, and it uses an OO-approach where appropriate. Programming paradigms are not exclusive.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;str.endswith()&lt;/code&gt; can operate on strings, while &lt;code&gt;len()&lt;/code&gt; can operate on &lt;em&gt;any&lt;/em&gt; sequence. Python has no interfaces, therefore there is no common type of which &lt;code&gt;len()&lt;/code&gt; operates on. Instead, Python uses protocols to add builtin behaviors to objects. And implementing protocols happens via double-underscored methods, &lt;code&gt;.__len__()&lt;/code&gt; in this example. Same principle as implementing &lt;code&gt;.__add__()&lt;/code&gt; to add language-support for addition, and you wouldn&amp;#39;t want to have a a method &lt;code&gt;.add()&lt;/code&gt; for every numeric type. The reason for having &lt;code&gt;len(x)&lt;/code&gt; and not &lt;code&gt;x.len()&lt;/code&gt; is to avoid name clashes (an empty class in python actually has no non-underscored methods, unlike inherited/builtin methods in other languages), and to be able to fulfill protocols in more than some ways. For example something can be turned into an iterator using &lt;code&gt;iter()&lt;/code&gt; if it either defines &lt;code&gt;.__iter__()&lt;/code&gt;, or is a sequence container by defining &lt;code&gt;.__getitem__()&lt;/code&gt;.&lt;/p&gt;\n\n&lt;p&gt;Even if it would have actual interfaces, it&amp;#39;s doubtful if &lt;code&gt;len()&lt;/code&gt; would be a method then. Other languages do this too in some cases, for example C++ has &lt;code&gt;std::begin()&lt;/code&gt; and &lt;code&gt;std::end()&lt;/code&gt;, which allows for a more generic approach than the &lt;code&gt;.begin()&lt;/code&gt; and &lt;code&gt;.end()&lt;/code&gt; member functions.&lt;/p&gt;\n\n&lt;p&gt;&lt;code&gt;str.join()&lt;/code&gt; is the way it is, because it operates on a string and on any iterable (be it lists, tuples, generators etc.). So you can put the functionality into the string (reads as &amp;quot;join that sequence with this string&amp;quot;), or into every iterable (aka as another protocol, reads as &amp;quot;join this sequence with that string&amp;quot;). It was decided to not do the latter just for the sake of consistency to other languages. You can also use methods as functions if you want: &lt;code&gt;str.join(&amp;quot;,&amp;quot;, [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;])&lt;/code&gt;&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;I don&amp;#39;t understand what you mean by &amp;quot;generators versus iterators versus comprehensions&amp;quot;. A generator is simply a subroutine that lazily returns singular values as a sequence using &lt;code&gt;yield&lt;/code&gt; instead of &lt;code&gt;return&lt;/code&gt;. That&amp;#39;s consistent with other languages (e.g. IEnumerable in C#, or any language supporting coroutines)&lt;/p&gt;\n\n&lt;p&gt;comprehensions are just a shorthand for a combination of two of the most common functional operations: &lt;code&gt;map()&lt;/code&gt; and &lt;code&gt;filter()&lt;/code&gt;. &lt;code&gt;(expr for item in sequence if condition)&lt;/code&gt; is equivalent to &lt;code&gt;map(expr, filter(condition, sequence))&lt;/code&gt;. Not sure what&amp;#39;s unintuitive. SQL does the same: &lt;code&gt;SELECT expr FROM table WHERE condition&lt;/code&gt;. And it&amp;#39;s consistent for list-, dict-, set- and generator-expressions.&lt;/p&gt;\n\n&lt;p&gt;What exactly is &amp;quot;iterator syntax&amp;quot;? If you conform to the iterator protocol, you can be an iterator. sequences can be iterated. comprehensions can be iterated. lists can be iterated. Just like &lt;code&gt;len()&lt;/code&gt;, it&amp;#39;s a builtin feature, whose protocol you can implement with &lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;__next__&lt;/code&gt;, as I mentioned before.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;I spent way too much time writing this, but hey, I learned stuff while researching. &lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc2uazf", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc2uazf/", "num_reports": null, "stickied": false, "created": 1483746180.0, "author_flair_text": null, "created_utc": 1483717380.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 3, "mod_reports": [], "mod_note": null, "distinguished": null}}], "before": null}}, "user_reports": [], "saved": false, "id": "dc28z4e", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "noratat", "can_mod_post": false, "send_replies": true, "parent_id": "t1_dc2770j", "score": 6, "approved_by": null, "downs": 0, "body": "The \"lambda\" syntax it has only allows single expressions, not true functions. A limitation that only exists because Guido couldn't think of a syntax he liked, not for any real architectural reason.\n\n---\n\nMost scripting languages have a simple and obvious way of interpolating information into strings:\n\n* Ruby: `\"Hello #{var}\"` (single quotes literal, `var` is an expression)\n* Bash: `\"Hello ${var}\"` (single quotes literal)\n* PHP: `\"Hello $var\"` (single quotes literal)\n* Groovy: `\"Hello ${var}\"` (single quotes literal, `var` is an expression)\n* Perl: `\"Hello $var\"`\n\nPython f-string syntax: `f\"Hello {var}\"`, `var` being an expression. But this wasn't introduced until **Python 3.6**, which was only just released (plus the whole Python 2/3 split). Otherwise you're stuck with manually interpolating strings or using awkward printf-like format calls, which are much harder to read.\n\n---\n\nThe language can't seem to make up its mind whether it will use C-style imperative APIs or a more OO-approach. For example, you have `str.endswith()` which operates in an OO fashion, other methods like `len()` are polymorphic global functions that operate on \"hidden\" interfaces, and still other methods like str.join() are just bizarre (having join be the method on the *delimiter* is counterintuitive and backwards from almost any other language with a similar method).\n\n---\n\nGenerators versus iterators versus comprehensions versus ...\nNone of which have consistent syntax unless you count the hidden interfaces, plus comprehensions have extra special syntax that operates backwards of intuition and the entire rest of the language by placing the logic before the context that gives it meaning.\n\netc etc", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The &amp;quot;lambda&amp;quot; syntax it has only allows single expressions, not true functions. A limitation that only exists because Guido couldn&amp;#39;t think of a syntax he liked, not for any real architectural reason.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;Most scripting languages have a simple and obvious way of interpolating information into strings:&lt;/p&gt;\n\n&lt;ul&gt;\n&lt;li&gt;Ruby: &lt;code&gt;&amp;quot;Hello #{var}&amp;quot;&lt;/code&gt; (single quotes literal, &lt;code&gt;var&lt;/code&gt; is an expression)&lt;/li&gt;\n&lt;li&gt;Bash: &lt;code&gt;&amp;quot;Hello ${var}&amp;quot;&lt;/code&gt; (single quotes literal)&lt;/li&gt;\n&lt;li&gt;PHP: &lt;code&gt;&amp;quot;Hello $var&amp;quot;&lt;/code&gt; (single quotes literal)&lt;/li&gt;\n&lt;li&gt;Groovy: &lt;code&gt;&amp;quot;Hello ${var}&amp;quot;&lt;/code&gt; (single quotes literal, &lt;code&gt;var&lt;/code&gt; is an expression)&lt;/li&gt;\n&lt;li&gt;Perl: &lt;code&gt;&amp;quot;Hello $var&amp;quot;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n\n&lt;p&gt;Python f-string syntax: &lt;code&gt;f&amp;quot;Hello {var}&amp;quot;&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt; being an expression. But this wasn&amp;#39;t introduced until &lt;strong&gt;Python 3.6&lt;/strong&gt;, which was only just released (plus the whole Python 2/3 split). Otherwise you&amp;#39;re stuck with manually interpolating strings or using awkward printf-like format calls, which are much harder to read.&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;The language can&amp;#39;t seem to make up its mind whether it will use C-style imperative APIs or a more OO-approach. For example, you have &lt;code&gt;str.endswith()&lt;/code&gt; which operates in an OO fashion, other methods like &lt;code&gt;len()&lt;/code&gt; are polymorphic global functions that operate on &amp;quot;hidden&amp;quot; interfaces, and still other methods like str.join() are just bizarre (having join be the method on the &lt;em&gt;delimiter&lt;/em&gt; is counterintuitive and backwards from almost any other language with a similar method).&lt;/p&gt;\n\n&lt;hr/&gt;\n\n&lt;p&gt;Generators versus iterators versus comprehensions versus ...\nNone of which have consistent syntax unless you count the hidden interfaces, plus comprehensions have extra special syntax that operates backwards of intuition and the entire rest of the language by placing the logic before the context that gives it meaning.&lt;/p&gt;\n\n&lt;p&gt;etc etc&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc28z4e", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc28z4e/", "num_reports": null, "stickied": false, "created": 1483702603.0, "author_flair_text": null, "created_utc": 1483673803.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 2, "mod_reports": [], "mod_note": null, "distinguished": null}}], "before": null}}, "user_reports": [], "saved": false, "id": "dc2770j", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "FelkCraft", "can_mod_post": false, "send_replies": true, "parent_id": "t1_dc21gi3", "score": -3, "approved_by": null, "downs": 0, "body": "You seem quite uninformed and opinionated, not providing proper examples for your claims. Can you back up any of your sentences?", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;You seem quite uninformed and opinionated, not providing proper examples for your claims. Can you back up any of your sentences?&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc2770j", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc2770j/", "num_reports": null, "stickied": false, "created": 1483700258.0, "author_flair_text": null, "created_utc": 1483671458.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 1, "mod_reports": [], "mod_note": null, "distinguished": null}}], "before": null}}, "user_reports": [], "saved": false, "id": "dc21gi3", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "noratat", "can_mod_post": false, "send_replies": true, "parent_id": "t3_5m6bdv", "score": 9, "approved_by": null, "downs": 0, "body": "&gt; it's fast, well documented, well connected to C, has a lot of libraries, \n\nAll fair points, and a big part of why I tolerate it.\n\n&gt; Because it has clean and agile syntax\n\n&gt; it's intuitive\n\nbwahahahahaha\n\nSure, maybe for toy scripts. But I found the language to be chock full of stupid gotchas and counterintuitive quirks, and the syntax only *looks* clean - especially coming from other languages. Plus it's the only contemporary mainstream language I've used that still lacks real lambdas (even Java got them as of Java 8).\n\nAnd for a language that prides itself on saying there should only be one way to do something... it has a LOT of ways to do common things. String interpolation is one of the worst offenders, with at least 3-4 different builtin ways to do it, and not one of them is as simple or intuitive as Ruby, Bash, Groovy, PHP, Perl, etc. The closest they got was f-strings, and even then it had to be a special snowflakes and omit the sigil.", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;blockquote&gt;\n&lt;p&gt;it&amp;#39;s fast, well documented, well connected to C, has a lot of libraries, &lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;All fair points, and a big part of why I tolerate it.&lt;/p&gt;\n\n&lt;blockquote&gt;\n&lt;p&gt;Because it has clean and agile syntax&lt;/p&gt;\n\n&lt;p&gt;it&amp;#39;s intuitive&lt;/p&gt;\n&lt;/blockquote&gt;\n\n&lt;p&gt;bwahahahahaha&lt;/p&gt;\n\n&lt;p&gt;Sure, maybe for toy scripts. But I found the language to be chock full of stupid gotchas and counterintuitive quirks, and the syntax only &lt;em&gt;looks&lt;/em&gt; clean - especially coming from other languages. Plus it&amp;#39;s the only contemporary mainstream language I&amp;#39;ve used that still lacks real lambdas (even Java got them as of Java 8).&lt;/p&gt;\n\n&lt;p&gt;And for a language that prides itself on saying there should only be one way to do something... it has a LOT of ways to do common things. String interpolation is one of the worst offenders, with at least 3-4 different builtin ways to do it, and not one of them is as simple or intuitive as Ruby, Bash, Groovy, PHP, Perl, etc. The closest they got was f-strings, and even then it had to be a special snowflakes and omit the sigil.&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc21gi3", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc21gi3/", "num_reports": null, "stickied": false, "created": 1483692778.0, "author_flair_text": null, "created_utc": 1483663978.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 0, "mod_reports": [], "mod_note": null, "distinguished": null}}, {"kind": "t1", "data": {"subreddit_id": "t5_2tex6", "approved_at_utc": null, "ups": 1, "mod_reason_by": null, "banned_by": null, "removal_reason": null, "link_id": "t3_5m6bdv", "likes": null, "no_follow": true, "replies": "", "user_reports": [], "saved": false, "id": "dc4irnj", "banned_at_utc": null, "mod_reason_title": null, "gilded": 0, "archived": true, "report_reasons": null, "author": "alerighi", "can_mod_post": false, "send_replies": true, "parent_id": "t3_5m6bdv", "score": 1, "approved_by": null, "downs": 0, "body": "The main reason for using python is only that it has a lot of libraries (for example, libraries for math and calculus, like scipy, numpy, etc), but for the rest, i prefer ruby", "edited": false, "author_flair_css_class": null, "collapsed": false, "is_submitter": false, "collapsed_reason": null, "body_html": "&lt;div class=\"md\"&gt;&lt;p&gt;The main reason for using python is only that it has a lot of libraries (for example, libraries for math and calculus, like scipy, numpy, etc), but for the rest, i prefer ruby&lt;/p&gt;\n&lt;/div&gt;", "subreddit_type": "public", "can_gild": true, "subreddit": "ProgrammerHumor", "name": "t1_dc4irnj", "score_hidden": false, "permalink": "/r/ProgrammerHumor/comments/5m6bdv/i_dont_like_it/dc4irnj/", "num_reports": null, "stickied": false, "created": 1483842921.0, "author_flair_text": null, "created_utc": 1483814121.0, "subreddit_name_prefixed": "r/ProgrammerHumor", "controversiality": 0, "depth": 0, "mod_reports": [], "mod_note": null, "distinguished": null}}], "before": null}}]